/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our Samples at https://docs.gradle.org/9.1.0/samples
 */
import org.apache.tools.ant.filters.ReplaceTokens
import java.time.Instant

plugins {
    id 'java'
    id 'application'
    id 'org.springframework.boot' version '3.2.5'
    id 'io.spring.dependency-management' version "1.1.5"
}

group = 'org.springframework.guides'
version = '0.0.1-SNAPSHOT'

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

sourceSets {
    intTest {
        java {
            srcDir file("src/intTest/java")
            compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
            runtimeClasspath += output + compileClasspath
        }
        resources.srcDir file("src/intTest/resources")
    }
}

configurations {
    intTestImplementation {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom implementation, testImplementation
    }
    intTestRuntimeOnly {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom runtimeOnly, testRuntimeOnly
    }
}

dependencies {
    // Project dependencies
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    testImplementation "org.junit.jupiter:junit-jupiter-api"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine"

    runtimeOnly 'com.h2database:h2'
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

springBoot {
    mainClass = 'payroll.PayrollApplication'
}


def targetDirPath = {
    if (project.hasProperty("dirPath") && project.property("dirPath")) {
        return project.property("dirPath")
    } else {
        return "build/deployment/default"
    }
}

tasks.register('cleanDeploymentDir', Delete) {
    description = 'Cleans a specific version-controlled directory using -PdirPath'

    def deploymentDirPath = targetDirPath()

    println "Cleaning contents of: $deploymentDirPath"
    delete deploymentDirPath

    doFirst {
        println "Starting to clean the deployment directory: $deploymentDirPath"
    }
}

tasks.register('copyArtifactToDir', Copy) {
    mustRunAfter 'cleanDeploymentDir'
    description = 'Generates a jar and copies it to a given directory'
    dependsOn 'bootJar'

    def deploymentDir = targetDirPath()
    delete deploymentDir

    from layout.buildDirectory.file("libs/${project.name}-${project.version}.jar")

    into deploymentDir

    doFirst {
        logger.lifecycle("Copying application artifact to: $deploymentDir")
    }
}

tasks.register('copyRuntimeExternalDependencies', Copy) {
    mustRunAfter 'cleanDeploymentDir'
    description = 'Copies a subset of runtime dependencies to /libs in a given directory'

    def libDir = "${targetDirPath()}/lib"
    delete libDir

    def subset = providers.gradleProperty("subset") ?: null

    if(subset.present) {
        from (configurations.runtimeClasspath) {
            include "**/*${subset.get()}"
        }
    } else {
        println "Subset is null, all of the lib files will be copied"
        from configurations.runtimeClasspath
    }

    into libDir

    doFirst {
        logger.lifecycle("Copying runtime dependencies to: $libDir")
    }
}

tasks.register("copyConfigurationFiles", Copy) {
    mustRunAfter 'cleanDeploymentDir'
    description = "Copies the configuration files to a given directory and patches them"

    def configDir = "${targetDirPath()}/config"
    delete configDir

    from(sourceSets.main.resources.sourceDirectories)
    {
        include "*.properties"
        filter(ReplaceTokens, tokens: [
                "version":  project.version.toString(),
                "buildTimestamp": Instant.now().toString()
        ])
    }

    into configDir

    doFirst {
        println "Copying configuration files to: $configDir"
    }
}

tasks.register("fullDeployment") {
    description = "Full deployment task that cleans a given directory, copies the artifact, runtime dependencies and configuration files"

    dependsOn 'cleanDeploymentDir'
    dependsOn 'copyArtifactToDir'
    dependsOn 'copyRuntimeExternalDependencies'
    dependsOn 'copyConfigurationFiles'

    doFirst {
        println "Starting full deployment..."
    }

    doLast {
        println "Full deployment completed."
    }
}

tasks.register('runArtifactJar', JavaExec) {
    dependsOn 'bootJar'

    if (System.properties['os.name'].toLowerCase().contains('windows')) {
        println "it's Windows"
    } else {
        println System.properties['os.name'].toLowerCase()
    }

    def jarDir = "build/libs/${project.name}-${project.version}.jar"

    classpath = files(jarDir)

    doFirst {
        logger.lifecycle("Running the application artifact: $jarDir")
    }
}

tasks.register('runArtifactScript', Exec) {
    dependsOn 'installDist'

    if (System.properties['os.name'].toLowerCase().contains('windows')) {
        commandLine "build/install/${project.name}/bin/${project.name}.bat"
    } else {
        commandLine "build/install/${project.name}/bin/${project.name}"
    }
}

tasks.register('compressJavadoc', Zip) {
    dependsOn javadoc

    from 'build/docs/javadoc'
    archiveFileName = 'JavadocBackup.zip'

    destinationDirectory = file('build/zips')
}

tasks.register('intTest', Test) {
    description = 'Runs the integration tests.'
    group = 'verification'

    useJUnitPlatform()

    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath

    shouldRunAfter test
}